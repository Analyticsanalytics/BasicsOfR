#Basic Function
Remove all the objects from R environment
rm(list=ls())

#If rStudio is giving error: "Error in plot.new() : figure margins too large in r"
par(mar=c(1,1,1,1))

#Counting how many unique elements are there column-wise. It will give only unique values. So if these values are less than the 
# observations for a variable, means there are duplicate values in that column
sapply(df, function(x) length(unique(x)))   #OR
rapply(df,function(x) length(unique(x)))

# Delete multiple columns at once.
df1 = df[, -c(1,2,4,10,11,14,15,17,18,21:24,31,32,42)]

# Impute all the missing values with the mean
df1$PPvD[is.na(df1$PPvD)] = mean(df1$PPvD, na.rm=TRUE)


#Getting all the quantiles of a variables
quantile(df$Prop_Balance, c(0.1,0.2, 0.3,0.4,0.5,0.6,0.7,0.8,0.9,1))

#Changing the name of variable with column index 2
colnames(df2)[2] = "Case_Id"

#Get the modal value of variable
library(modeest)
mlv(df$AvgDailyBalance, method = "mfv")

#Generating 2000 cases with zero and ones and in the ratio of 14% and 18% respectively
xx = sample(c(0,1), 2000, replace=TRUE, prob = c(0.14, 0.86))
prop.table(table(xx))

#Create a new variable mpg01 in df Auto which includes 1 if the value of mpg is greater than its median and zero otherwise
Auto$mpg01 = ifelse(Auto$mpg > median(Auto$mpg), 1, 0)

#If values of power are greater than 300k, cap them at 300k. Else leave em as it is.
df1$Power = ifelse(df1$Power > 300000, 300000, df1$Power)


#Merging by two or more diff columns
zz = merge(train, test, by =c("ccid", "conno", "web_top_n"))

#Removing duplicated observations from a df.
data1 = data[!duplicated(data),] #OR WE CAN USE
data1 = unique(data)


##############   TREATMENT OF MISSING VALUES   ###############################
#Checking if there is any missing element in the dataset
length(Dataset[is.na(Dataset)])

#Show the missing values in all columns
colSums(is.na(train)) OR sapply(train, function(x) sum(is.na(x)))

#Show only columns which have one or more missing values
M <- sapply(train, function(x) sum(is.na(x)))
M[M>0]

#####   DRAWING MUPLTIPLE HISTOGRAMS OF NUMERICAL VALUES   ########
par(mfrow=c(2, 2))        #Taking two rows & two columns
for (i in 6:9) {           #Taking 6th to 9th columns since they're numerical
  hist(train[,i], main=colnames[i], probability=TRUE, col="gray", border="white")
}

#Alternatively, we can use individual plots like this
plot(Auto$displacement, main="Displacement", col="red", type="p")

#####   DRAWING MUPLTIPLE BOXPLOTS OF NUMERICAL VALUES   ########
par(mfrow=c(2, 2))
for (i in 6:9) {
  boxplot(train[,i], main=colnames[i], probability=TRUE, col="gray", border="black",  horizontal=TRUE)
}
###OR WE can use below script
boxplot(train[,6:9], horizontal=TRUE, main="Crime Rates in US") #For multiple variables
boxplot(train$Field9, horizontal=TRUE) #For single variable



##Checking the classes of all the variables in a dataset
sapply(train, function (x) class(x))

#Making comparison plots for multiple numerical variables
pairs(train[,6:9]) #Here we're making plots for 6th to 9th variables

#Making the correlation of all but one (Destination, it's categorical) variables
cor(subset(Airlines, select=-Destination))


#args function give the argument of any function
args(geom_line)
#How many TotalDelay are actually zero. It will show values in T & F
summary(Airlines$TotalDelay > 0)

#Flights with TotalDelay of more than or equal to 5 hours and TimeTaken less than 10 hours
subset(Airlines, TotalDelay >= 5 & TimeTaken < 10)
### OR we can use the below code for same
Airlines[Airlines$TotalDelay >= 5 & Airlines$TimeTaken < 10, ]

#Flights with TotalDelay of less than 6 hours OR TimeTaken more than 10 hours
subset(Airlines, TotalDelay < 6 | TimeTaken > 8)

There so many missing values in the Airlines df. we can get only available values using "complete. cases"
good = comple.cases(Airlines) #Taking logical values of missing & available values (T/F)
Airlines[good][,1:20] #Getting only available values, 1 to 20 columns and all the rows. It will remove rows with NA values 




##MAKING ORDERED FACTORS###
#Checking the levels of factor variable age.range
levels(Airlines$age.range)
library(ggplot2)
qplot(data=Airlines, x=age.range) #Suppose the histogram is not in the ordered format

#We can make the histogram in ordered format using this
Airlines$age$range = ordered(Airlines$age.range, level = c("Under 18", "18-24", "25-34", "35-44", "45-54", "55-64", "65 or Above"))
ggplot(aes(x=age.range), data=Airlines) + geom_histogram()
##Or this
levels(Airlines$age.range) = c("Under 18", "18-24", "25-34", "35-44", "45-54", "55-64", "65 or Above")
ggplot(aes(x=age.range), data=Airlines) + geom_histogram()
#Or this. Here Ordered=T, it should be in that order as in levels and use ggplot instead of qplot
Airlines$age.range = factor(Airlines$age.range, level = c("Under 18", "18-24", "25-34", "35-44", "45-54", "55-64", "65 or Above", ordered=T))
ggplot(aes(x=age.range), data=Airlines) + geom_histogram()



#Removing a variable (TotalDelay) from the dataset
Airlines$TotalDelay = NULL

#Remove all the existing contents from R studio
rm(list=ls())

####Deriving TIME VARIABLES IN THE DATASET FROM DATE VARIABLE
#Suppose the time format in Airlines is like this "2015-05-26 21:45:32". We can add the time variables using the strptime() function of PubDate
#Here we've used "%Y-%m-%d %H:%M:%S" bcz date is currently in this format
Airlines$PubDate = strptime(Airlines$PubDate, "%Y-%m-%d %H:%M:%S")

#Now add the variables weekday, Hour & Month in the dataset
Airlines$Weekday = Airlines$PubDate$wday
Airlines$Hour = Airliness$PubDate$hour
Airlines$Month = Airlines$PubDate$mon



#Copying a column to a df from another df. Here we copy sold column from FLipkart to descriptionText
descriptionText$sold = Flipkart$sold

#Suppose there are no columns name in a dataset movie. Add the columns using colnames function
colnames(movies) = c("ID", "Title", "ReleaseDate", "VideoReleaseDate", "IMDB", Thriller", "War", "Western")

#add a "M" in front of all the variable names in movies. check ?paste0()
names(movies) = paste0("M", names(movies))

#Creating a dummy variable Popular in the movies dataset
Nmovies$Popular = rep(0,nrow(movies))


#Normalizing the data using caret package. for each variable, the normalization process subtracts the mean and divides
#by the standard deviation.In the normalized dataset, all of the variables should have mean 0 and standard deviation 1
library(caret)
preproc = preProcess(Flipkart)
FlipNorm = predict(preproc, Flipkart)

############# SPLITTING THE DATA INTO TRAIN & TEST SET ######################
Read the file:-Airlines = read.csv(file = "C:\\Users\\AirlineDelay.csv"). Use stringAsFactors=F if there is a lot of text data
•	Splitting dataset which has continuousdependant variables
spl=sample(nrow(Airlines),0.7*nrow(Airlines)) 
AirlinesTrain = Airlines[spl,]
AirlinesTest = Airlines[-spl,]

•	Splitting dataset which has categorical dependent variables
library(caTools)
split = sample.split(quality$PoorCare, SplitRatio = 0.75) 
split #We can see that split has been divided into T & F values
qualityTrain = subset(quality, split == TRUE) #traning set
qualityTest = subset(quality, split == FALSE) #testing set

•	Splitting the data using another method
NewsTrain1 = news[1:6532, ]
NewsTest1 = news[6533:8402, ]


########      LUBRIDATE DATE EXTRACTION       ################
library(lubridate)
mtrain$Date = ymd(mtrain$Date) #ymd bcs date is in 2014-4-23 format. We use mdy if it is 4-23-2014 format and so on. We also use
ymd_hms if there are hour, minutes and seconds

mtrain$WeekNum = week(mtrain$Date)
mtrain$Month = month(mtrain$Date)
mtrain$Day = day(mtrain$Date)
mtrain$year = year(mtrain$Date)
mtrain$hour = hour(mtrain$Date)

###################     Using swirl package for R     ####################
install.packages("swirl")
packageVersion("swirl")
library(swirl)
install_from_swirl("Getting and Cleaning Data")
swirl()
install_from_swirl("R Programming")


###################     Outlier Treatment : Percentile Capping   ####################

df is dataset here
pcap <- function(x){
  for (i in which(sapply(x, is.numeric))) {
    quantiles <- quantile( x[,i], c(.05, .95 ), na.rm =TRUE)
    x[,i] = ifelse(x[,i] < quantiles[1] , quantiles[1], x[,i])
    x[,i] = ifelse(x[,i] > quantiles[2] , quantiles[2], x[,i])}
  x}
df1 = pcap(df) #df1 will have no outliers.
